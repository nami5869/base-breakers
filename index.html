<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Base Breaker â€” Minimal Working Preview</title>
<style>
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:#0b1220;display:grid;place-items:center}
  canvas{display:block;border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
</style>
</head>
<body>
<canvas id="game" width="360" height="640" aria-label="Base Breaker"></canvas>
<script>
// ======= ZERO-DEPENDENCY, WORKING PREVIEW =======
const cvs=document.getElementById('game');
const ctx=cvs.getContext('2d');
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
let W=360,H=640; // logical size

function fit(){
  // phone-like 9:16 canvas that always shows something
  const maxW=Math.min(420, (window.innerWidth||420)-24);
  const targetW=Math.max(300, Math.min(maxW, Math.floor((window.innerHeight||700)*9/16)));
  const targetH=Math.floor(targetW*16/9);
  const dpr=window.devicePixelRatio||1;
  cvs.style.width=targetW+"px"; cvs.style.height=targetH+"px";
  cvs.width=Math.max(1,Math.floor(targetW*dpr));
  cvs.height=Math.max(1,Math.floor(targetH*dpr));
  ctx.setTransform(dpr,0,0,dpr,0,0);
  W=targetW; H=targetH;
}
window.addEventListener('resize',fit);

// game objects
const paddle={w:100,h:12,x:0,y:0};
const ball={x:0,y:0,r:8,vx:4,vy:-4};
let bricks=[]; let score=0; let running=true;

function rr(x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath();}
function drawBrick(x,y,w,h){const r=Math.min(10,Math.min(w,h)*0.25);ctx.save();ctx.shadowColor='rgba(110,74,255,0.45)';ctx.shadowBlur=8;ctx.fillStyle='#6E4AFF';rr(x,y,w,h,r);ctx.fill();ctx.restore();ctx.fillStyle='#fff';ctx.font=`900 ${Math.floor(h*0.75)}px system-ui`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText('$',x+w/2,y+h*0.56);} 

function init(){
  fit();
  paddle.x=W/2-paddle.w/2; paddle.y=H-28; 
  ball.x=W/2; ball.y=H-40; ball.vx=4; ball.vy=-4;
  // bricks centered
  bricks.length=0; const cols=8, rows=6, bw=60, bh=32, pad=10;
  const totalW=cols*bw+(cols-1)*pad; const sx=(W-totalW)/2; const sy=60;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) bricks.push({x:sx+c*(bw+pad),y:sy+r*(bh+pad),w:bw,h:bh,alive:true});
}

function bg(){const g=ctx.createLinearGradient(0,0,0,H);g.addColorStop(0,'#0b1428');g.addColorStop(1,'#0a0f1f');ctx.fillStyle=g;ctx.fillRect(0,0,W,H);} 
function draw(){
  bg();
  // paddle
  ctx.fillStyle='#a7b7ff'; rr(paddle.x,paddle.y,paddle.w,paddle.h,8); ctx.fill();
  // ball
  ctx.save(); ctx.shadowColor='rgba(147,197,253,0.9)'; ctx.shadowBlur=10; ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.restore();
  // bricks
  for(const b of bricks){ if(b.alive) drawBrick(b.x,b.y,b.w,b.h); }
}

function step(){
  if(!running){ draw(); return; }
  // basic physics
  ball.x+=ball.vx; ball.y+=ball.vy;
  if(ball.x<ball.r||ball.x>W-ball.r) ball.vx*=-1;
  if(ball.y<ball.r) ball.vy*=-1;
  if(ball.y>H){ init(); } // reset on fall so preview never blanks
  // paddle collide
  if(ball.x>paddle.x && ball.x<paddle.x+paddle.w && ball.y+ball.r>paddle.y){ ball.vy*=-1; ball.y=paddle.y-ball.r; }
  // bricks collide
  for(const b of bricks){ if(b.alive && ball.x>b.x && ball.x<b.x+b.w && ball.y>b.y && ball.y<b.y+b.h){ b.alive=false; ball.vy*=-1; score+=10; break; } }
  draw(); requestAnimationFrame(step);
}

addEventListener('mousemove',e=>{ const r=cvs.getBoundingClientRect(); const x=Math.max(0,Math.min(r.width,e.clientX-r.left)); paddle.x=clamp(x-paddle.w/2,0,W-paddle.w);});

init(); draw(); step();
</script>
</body>
</html>
